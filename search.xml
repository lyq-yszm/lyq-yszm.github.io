<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript</title>
      <link href="2020/10/06/JavaScript/"/>
      <url>2020/10/06/JavaScript/</url>
      
        <content type="html"><![CDATA[<p>常见问题. </p><h2 id="语言特性"><a href="#语言特性" class="headerlink" title="语言特性"></a>语言特性</h2><p>运行在客户端浏览器上；<br>不用预编译，直接解析执行代码；<br>是弱类型语言，较为灵活；<br>与操作系统无关，跨平台的语言；<br>脚本语言、解释性语言。</p><h2 id="javascript数据类型"><a href="#javascript数据类型" class="headerlink" title="javascript数据类型"></a>javascript数据类型</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>string、number、null、undefined、boolean、symbol(ES6新增) 变量值存放在栈内存中，可直接访问和修改变量的值<br>基本数据类型不存在拷贝，好比如说你无法修改数值1的值</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>Object Function RegExp Math Date 值为对象，存放在堆内存中<br>在栈内存中变量保存的是一个指针，指向对应在堆内存中的地址。<br>当访问引用类型的时候，要先从栈中取出该对象的地址指针，然后再从堆内存中取得所需的数据</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>为什么备份的数组对象也会发生变化，这里就涉及到你用的‘备份’其实是一种浅拷贝</p><h4 id="简单的引用拷贝"><a href="#简单的引用拷贝" class="headerlink" title="简单的引用拷贝"></a>简单的引用拷贝</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1,2,3,4];</span><br><span class="line">var b &#x3D; a;</span><br><span class="line">a[0] &#x3D; 0;</span><br><span class="line">console.log(a,b); &#x2F;&#x2F;(0,2,3,4) (0,2,3,4) </span><br></pre></td></tr></table></figure><p>Array.prototype.slice 和 Array.prototype.concat 看似深拷贝，其实质上还是浅拷贝<br>当数组a中包含对象时， Array.prototype.slice 和 Array.prototype.cancat 拷贝出来数组中的对象还是共享同一内存地址，所以本质上归属浅拷贝<br>Object.assign 原理也是一样的（对于对象的属性都为基本类型可以当成深拷贝）  </p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝是可以完美的解决浅拷贝的弊端，重新开辟一块地址，深拷贝出来的属性的基本类型值都是相同的。</p><h4 id="JSON内置对象深拷贝"><a href="#JSON内置对象深拷贝" class="headerlink" title="JSON内置对象深拷贝"></a>JSON内置对象深拷贝</h4><p>JSON 对象是ES5中引入的新的类型（支持的浏览器为IE8+），JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;age:1,name:&#39;ccy&#39;,info:&#123;address:&#39;wuhan&#39;,interest:&#39;playCards&#39;&#125;&#125;;</span><br><span class="line">var b &#x3D; JSON.parse(JSON.stringify(a));</span><br><span class="line">a.info.address &#x3D; &#39;shenzhen&#39;;</span><br><span class="line">console.log(a.info,b.info);</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>闭包是指那些能够访问自由变量的函数，自由变量是指在函数中使用的，但既不是函数参数又不是函数的局部变量的变量，由此可以看出，闭包=函数+函数能够访问的自由变量，所以从技术的角度讲，所有JS函数都是闭包，但是这是理论上的闭包，还有一个实践角度上的闭包，从实践角度上来说，只有满足1、即使创建它的上下文已经销毁，它仍然存在，2、在代码中引入了自由变量，才称为闭包</p><h3 id="闭包的应用："><a href="#闭包的应用：" class="headerlink" title="闭包的应用："></a>闭包的应用：</h3><p>1、模仿块级作用域。2、保存外部函数的变量。3、封装私有变量</p><h3 id="为什么要用："><a href="#为什么要用：" class="headerlink" title="为什么要用："></a>为什么要用：</h3><p>匿名自执行函数：我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。<br>结果缓存：我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间，那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</p><h3 id="闭包的特点："><a href="#闭包的特点：" class="headerlink" title="闭包的特点："></a>闭包的特点：</h3><p>1.让外部访问函数内部变量成为可能<br>2.局部变量会常驻内存中<br>3.可以避免使用全局变量，防止全局变量污染<br>4.会造成内存泄露（有一块内存被长期占用，得不到释放）</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function outerFn()&#123;</span><br><span class="line">    var i &#x3D; 0; </span><br><span class="line">    function innerFn()&#123;</span><br><span class="line">    i++;</span><br><span class="line">    console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">    return innerFn;</span><br><span class="line">&#125;</span><br><span class="line">var inner &#x3D; outerFn();  &#x2F;&#x2F;每次外部函数执行的时候，外部函数的地址不同，都会重新创建一个新的地址</span><br><span class="line">inner();</span><br><span class="line">inner();</span><br><span class="line">inner();</span><br><span class="line">var inner2 &#x3D; outerFn();</span><br><span class="line">inner2();</span><br><span class="line">inner2();</span><br><span class="line">inner2();   &#x2F;&#x2F;1 2 3 1 2 3  innerFn函数常驻内存，并且outerFn的变量也没有被销毁，可以被外部访问</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
